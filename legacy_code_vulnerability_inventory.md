# Legacy Code Vulnerabilities

---

## High Priority

1. **SQL Injection Vulnerabilities**  
   SQL queries are constructed using string concatenation with user inputs (e.g., in login, registration, and search functions), making the system vulnerable to SQL injection attacks.

2. **Weak MD5 Password Hashing**  
   Passwords are hashed using MD5, which is outdated and susceptible to brute force attacks.

3. **Hard-Coded Secret Key**  
   The secret key is embedded directly in the source code.

4. **Critical Dependency Vulnerabilities**  
   - **Werkzeug Debugger Vulnerability:** Older versions have insufficient randomness for the debugger PIN, especially in Docker environments.  
   - **Flask Memory Usage Vulnerability:** Versions before 0.12.3 can experience high memory usage due to malformed JSON data.  
   - **Permanent Session Cookie Issue:** Some Flask configurations result in session cookies that do not expire because of missing `Vary` headers.  
   - **Jinja2 Sandbox Bypass:** Older versions of Jinja2 allow sandbox escapes via crafted template inputs.  
   - **Setuptools Command Injection:** Setuptools versions ≤ 65.5.0 are vulnerable to command injection via malicious package URLs.

---

## Medium Priority

1. **Lack of CSRF Protection**  
   Application forms lack CSRF tokens, leaving them vulnerable to cross-site request forgery attacks.

2. **Inadequate Input Validation & Sanitization**  
   User inputs are not thoroughly validated or sanitized, increasing the risk of various injection attacks.

3. **High Resource Usage When Parsing Multipart Form Data**  
   Parsing large file uploads or multipart form data can lead to excessive resource consumption.

4. **Jinja2 Temporary File and Local Privilege Escalation Concerns**  
   Older versions of Jinja2 may mishandle temporary files, potentially allowing local privilege escalation.

5. **Hard-Coded Database Paths**  
   Database and schema file paths are hard-coded and relative, which may cause issues in different deployment environments.

---

## Low Priority

1. **Minimal Error Handling & Logging**  
   Error handling is managed in an ad hoc manner, with minimal logging for debugging and auditing.

2. **Global Database Connection Management**  
   Reliance on Flask’s global `g` object for database connections can lead to maintainability issues.

3. **Lack of Role-Based Access Controls**  
   The system differentiates only between logged-in and anonymous users without finer-grained access control.

4. **Monolithic Code Structure**  
   All functionality is contained within a single file, reducing clarity and maintainability.

5. **Lack of Automated Testing**  
   There are no automated tests in place, increasing the risk of undetected regressions.
